//===-- VAXISelDAGToDAG.cpp - A dag to dag inst selector for VAX ------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the VAX target.
//
//===----------------------------------------------------------------------===//

#include "VAX.h"
#include "VAXTargetMachine.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAG.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/CodeGen/TargetLowering.h"
#include "llvm/IR/CallingConv.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Intrinsics.h"
#include <cstdint>
// #include "llvm/IR/IntrinsicsVAX.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"
using namespace llvm;

#define DEBUG_TYPE "vax-isel"
#define PASS_NAME "VAX DAG->DAG Pattern Instruction Selection"

/// VAXDAGToDAGISel - VAX specific code to select VAX machine
/// instructions for SelectionDAG operations.
///
namespace {
class VAXDAGToDAGISel : public SelectionDAGISel {

public:
  VAXDAGToDAGISel() = delete;

  VAXDAGToDAGISel(VAXTargetMachine &TM, CodeGenOptLevel OptLevel)
      : SelectionDAGISel(TM, OptLevel) {}

  void Select(SDNode *N) override;

  bool selectVaxOp(llvm::SDValue &Parent, llvm::SDValue &Sentinel,
                   llvm::SDValue &Mode, llvm::SDValue &Literal) {
    return false;
  }
  bool selectBVopSrc(SDValue Addr, SDValue &Base, SDValue &Offset,
                     SDValue &Other) {
    return false;
  }
  bool selectWVopSrc(SDValue Addr, SDValue &Base, SDValue &Offset,
                     SDValue &Other) {
    return false;
  }
  bool selectFVopSrc(SDValue Addr, SDValue &Base, SDValue &Offset,
                     SDValue &Other) {
    return false;
  }
  bool selectDVopSrc(SDValue Addr, SDValue &Base, SDValue &Offset,
                     SDValue &Other) {
    return false;
  }
  bool selectGVopSrc(SDValue Addr, SDValue &Base, SDValue &Offset,
                     SDValue &Other) {
    return false;
  }
  bool selectHVopSrc(SDValue Addr, SDValue &Base, SDValue &Offset,
                     SDValue &Other) {
    return false;
  }
  bool selectOVopSrc(SDValue Addr, SDValue &Base, SDValue &Offset,
                     SDValue &Other) {
    return false;
  }

  bool selectVPcAddrOp(SDValue Addr, SDValue &Base, SDValue &Offset) {
    return false;
  }

  bool selectLVopSrc(SDValue N, SDValue &Direct, SDValue &Base,
                     SDValue &Offset) {

    const DataLayout &DL = CurDAG->getDataLayout();
    SDLoc SDL = SDLoc(N);

    LLVM_DEBUG(dbgs() << "gothere\n");
    CurDAG->dump();
    N.dump();

    // Address modes - literal and immediate constant
    if (auto *C = dyn_cast<ConstantSDNode>(N)) {
      MVT VT = MVT::i32;
      unsigned BitWidth = VT.getSizeInBits();
      int64_t val;

      val = C->getZExtValue();
      if (!llvm::isUIntN(BitWidth, val))
        return false;

      Direct = CurDAG->getTargetConstant(val, SDL, MVT::i32);
      Base = SDValue();
      Offset = SDValue();
      return true;
    }

    if (N.getOpcode() == ISD::CopyFromReg) {
      Direct = N;
      Base = SDValue();
      Offset = SDValue();
      return true;
    }

    if (N.getOpcode() == ISD::FrameIndex) {
      int FI = cast<FrameIndexSDNode>(N)->getIndex();
      Base = CurDAG->getTargetFrameIndex(FI, TLI->getPointerTy(DL));
      Offset = CurDAG->getTargetConstant(0, SDL, MVT::i32);
      Direct = SDValue();
      return true;
    }

    if (N.getOpcode() == ISD::LOAD) {
      auto *LD = cast<LoadSDNode>(N);
      SDValue Ptr = LD->getBasePtr();
      unsigned Opcode = Ptr.getOpcode();

      switch (Opcode) {
      case ISD::CopyFromReg:
        Base = Ptr;
        Offset = SDValue();
        Direct = SDValue();
        break;
      case ISD::FrameIndex: {
        int FI = cast<FrameIndexSDNode>(Ptr)->getIndex();
        Base = CurDAG->getTargetFrameIndex(FI, TLI->getPointerTy(DL));
        Offset = CurDAG->getTargetConstant(0, SDL, MVT::i32);
        Direct = SDValue();
        break;
      }
      default:
        LLVM_DEBUG(dbgs() << "No load match: " << N.getOpcode() << "\n");
        return false;
      }
      return true;
    }

    N.dump();
    LLVM_DEBUG(dbgs() << "No  match: " << N.getOpcode() << "\n");
    return false;
  }

  // Include the pieces autogenerated from the target description.
#include "VAXGenDAGISel.inc"
};

class VAXDAGToDAGISelLegacy : public SelectionDAGISelLegacy {
public:
  static char ID;
  explicit VAXDAGToDAGISelLegacy(VAXTargetMachine &TM, CodeGenOptLevel OptLevel)
      : SelectionDAGISelLegacy(
            ID, std::make_unique<VAXDAGToDAGISel>(TM, OptLevel)) {}
};
} // end anonymous namespace

char VAXDAGToDAGISelLegacy::ID = 0;

INITIALIZE_PASS(VAXDAGToDAGISelLegacy, DEBUG_TYPE, PASS_NAME, false, false)

/// createVAXISelDag - This pass converts a legalized DAG into a
/// VAX-specific DAG, ready for instruction scheduling.
///
FunctionPass *llvm::createVAXISelDag(VAXTargetMachine &TM,
                                     CodeGenOptLevel OptLevel) {
  return new VAXDAGToDAGISelLegacy(TM, OptLevel);
}

void VAXDAGToDAGISel::Select(SDNode *N) { SelectCode(N); }
